local a={head=true,torso=true,right_arm_vis=true,left_arm_vis=true,right_leg_vis=true,left_leg_vis=true}local b={{"head","torso"},{"torso","right_arm_vis"},{"torso","left_arm_vis"},{"torso","right_leg_vis"},{"torso","left_leg_vis"}}local c=Color3.fromRGB(255,70,70)local d=Color3.fromRGB(70,155,255)local e=2 local f=10 local g=0.06 local h=0.04 local i=game:GetService("Players")local j=game:GetService("RunService")local k=game:GetService("Workspace")local l=k.CurrentCamera local m=i.LocalPlayer local n=k:WaitForChild("characters")local o=setmetatable({},{__mode="k"})local function p()local L=Drawing.new("Line")L.Visible=false L.Thickness=e L.Transparency=1 L.Color=d return L end local function q(char)local bucket=o[char]if bucket then return bucket end bucket={lines={},lastUpdate=0,nextIndex=1,order={},partCache={},losCache={}}for _=1,#b do table.insert(bucket.lines,p())end bucket.order=table.clone(b)for II=#bucket.order,2,-1 do local JJ=math.random(II)bucket.order[II],bucket.order[JJ]=bucket.order[JJ],bucket.order[II]end o[char]=bucket return bucket end local function r(char)local bucket=o[char]if not bucket then return end for _,L in ipairs(bucket.lines)do pcall(function()L:Remove()end)end o[char]=nil end local function s(char,name)local bucket=o[char]local cached=bucket and bucket.partCache[name]if cached and cached.Parent then return cached end local PP=char:FindFirstChild(name)if PP and PP:IsA("BasePart")then if bucket then bucket.partCache[name]=PP end return PP end if bucket then bucket.partCache[name]=nil end return nil end local function t(char,part,ignoreSelf)if not part then return false end local origin=l.CFrame.Position local target=part.Position local params=RaycastParams.new()params.FilterType=Enum.RaycastFilterType.Exclude local ignore={char}if ignoreSelf and m.Character then table.insert(ignore,m.Character)end params.FilterDescendantsInstances=ignore params.IgnoreWater=true local result=k:Raycast(origin,target-origin,params)return(not result)or(result.Instance and result.Instance:IsDescendantOf(char))end local u=0 j.RenderStepped:Connect(function()u=0 for _,char in ipairs(n:GetChildren())do if char and char~=m.Character then local bucket=q(char)local now=os.clock()local dueAt=bucket.lastUpdate+g+(bucket.jitter or 0)if now>=dueAt then local refreshCount=math.max(1,math.floor(f/math.max(1,#o)))local refreshed=0 for _=1,#bucket.order do if u>=f then break end if refreshed>=refreshCount then break end local aName,bName=bucket.order[bucket.nextIndex][1],bucket.order[bucket.nextIndex][2]bucket.nextIndex=bucket.nextIndex+1 if bucket.nextIndex>#bucket.order then bucket.nextIndex=1 end local aPart=s(char,aName)if aPart and u<f then bucket.losCache[aName]=t(char,aPart,true)u+=1 end local bPart=s(char,bName)if bPart and u<f then bucket.losCache[bName]=t(char,bPart,true)u+=1 end refreshed+=1 end bucket.lastUpdate=now bucket.jitter=(math.random()-0.5)*2*h end local pos2d={}for name in pairs(a)do local part=s(char,name)if part then local sp,on=l:WorldToViewportPoint(part.Position)if on then pos2d[name]=Vector2.new(sp.X,sp.Y)else pos2d[name]=nil end else pos2d[name]=nil end end for II,link in ipairs(b)do local aa,bb=link[1],link[2]local p1,p2=pos2d[aa],pos2d[bb]local L=bucket.lines[II]if p1 and p2 then L.From=p1 L.To=p2 local exposed=(bucket.losCache[aa]==true)or(bucket.losCache[bb]==true)L.Color=exposed and c or d L.Visible=true else L.Visible=false end end end end for char,_ in pairs(o)do if not char or not char.Parent then r(char)end end end)i.LocalPlayer.AncestryChanged:Connect(function(_,parent)if not parent then for char in pairs(o)do r(char)end end end)
